
let rec maximum = function
  |[]->failwith "empty list"
  |[q]->q
  |q::t-> max (q) (maximum t);;
(* exercice 2 (suite fibo)*)

let mem_fibo = Hashtbl.create 997;;

let remplir_fib n = 
  let lst = ref [] in 
  let rec fibo n = 
    try Hashtbl.find mem_fibo n with
    |Not_found->let res = if n<2 then 1 else fibo (n-1) + fibo (n-2)
        in Hashtbl.add mem_fibo n res;res
  in for i = 0 to n do (lst:= fibo i::(!lst)) done;List.rev !lst;; 
  

(*exerciece 3 (arbre binaire)*)
type arbre_bin =Vide|N of int * arbre_bin * arbre_bin;;




Random.self_init();;

let arbre_bin_alea n = 
  let lg = Random.int n in
  let rec aux k l = match l with
    |0->Vide 
    |l-> let r = Random.int l in N(k+r,aux k r,aux (k+r+1) (l-r-1));
  in N(lg,aux 0 lg,aux (lg+1) (n-1-lg));;

let rec taille_bin = function
  |Vide->0
  |N(_,g,d)-> 1 + taille_bin g + taille_bin d;;

let rec hauteur_bin = function
  |Vide-> -1
  |N(_,g,d)-> 1 + max(taille_bin g)(taille_bin d);; 


let rec affiche_prefixe = function
  |Vide-> ()
  |N(q,Vide,Vide)-> print_int q
  |N(q,g,d)->print_int q;affiche_prefixe g ;affiche_prefixe d;; 


let rec infixe =function
  |Vide->[]
  |N(q,g,d)->infixe g @ (q::(infixe d));;


(*faux, pas de programamtion imppÃ©rative *)
let infixe b_tree = 
  let lst = ref [] in 
  let rec aux =function
    | Vide-> ()
    |N(q,d,g)-> aux d; lst:= q::(!lst) ;aux g
  in aux b_tree;List.rev (!lst);;      
(*corrige*)
(*parcours infixe a l'inverse en mettant
  dans la liste acc le dernier au premier element*)

let infixe_ b_tree = 
  let rec aux acc = function 
    |Vide->acc
    |N(q,g,d)->aux (q::(aux acc d)) g
  in aux [] b_tree;;
  
  
(*exercice 4*)

type arbre = Noeud of int * arbre list;; 


let rec vers_lst = function
  |Vide->[]
  |N(x,g,d)->Noeud (x,vers_lst g):: vers_lst d;;


let arbre_alea n = 
  let a = arbre_bin_alea (n-1) in 
  Noeud(n-1,vers_lst a);;


let rec taille arbre = 
  let rec somme= function
    |[]->0
    |q::t->q+somme t
  in let Noeud(n,lst) = arbre in 1 + somme (List.map taille lst);; 

(*correction*)

let rec taille1 (Noeud(x,lst)) = match lst with
  |[]->1
  |q::t->taille1 q + taille1 (Noeud(x,t)) ;;

(*prend une liste d'arbre et calcule la somme des tailles*)
let rec taille2 arbre = 
  let rec aux = function 
    |[]->0
    |Noeud(x,lst)::t->1 + aux lst+ aux t 
  in aux [arbre];;

let rec taille3 (Noeud(x,lst)) =
  1 + List.fold_left (fun a b-> a + b) 0 (List.map taille3 lst);; 

let rec taille4 (Noeud(x,lst))=
  1 + List.fold_left (fun a b -> a + taille3 b) 0 (lst) ;;


let rec hauteur0 (Noeud(x,lst))=match lst with 
  |[]->0
  |q::t-> max (1 + hauteur0 q )(hauteur0 (Noeud(x,t)));;
  
            
let suffix arbre= 
  let rec aux  acc = function
    |[]->acc
    |Noeud(x,q)::t-> aux (x:: aux acc t) q
  in aux [][arbre];;


      
let rec bin_vers_arbre  =function
  |N(x,Vide,Vide)->Noeud(x,[])
  |N(x,g,Vide)|N(x,Vide,g) -> Noeud(x,[bin_vers_arbre g])
  |N(x,g,d)-> Noeud(x,[bin_vers_arbre g;bin_vers_arbre d]);;
    
    
    
    
    
    
    
